# ML Модель для классификации неисправностей подшипников

Модуль машинного обучения для определения состояния подшипников по вибрационным данным.

## Описание

Модель классифицирует состояние подшипника на 4 категории:
1. **Норма** - подшипник работает в штатном режиме
2. **Износ внутреннего кольца** - обнаружен износ внутреннего кольца подшипника
3. **Износ внешнего кольца** - обнаружен износ внешнего кольца подшипника
4. **Неисправность шарика** - обнаружена неисправность шарика подшипника

## Структура модуля

```
ml_model/
├── __init__.py              # Инициализация пакета
├── feature_extractor.py     # Извлечение признаков из вибрационных данных
├── bearing_classifier.py    # Классификатор неисправностей
├── train_model.py          # Скрипт для обучения модели
├── predictor.py            # Модуль для использования модели
└── README.md               # Документация
```

## Установка зависимостей

```bash
pip install -r ../backend/requirements.txt
```

## Обучение модели

Для обучения модели на синтетических данных выполните:

```bash
cd ml_model
python train_model.py
```

Скрипт:
- Генерирует синтетические данные для всех 4 классов
- Обучает модель Random Forest
- Сохраняет модель в `bearing_classifier_model.joblib`
- Выводит метрики качества модели

## Использование модели

### Пример 1: Базовое использование

```python
from ml_model.predictor import create_predictor

# Создаем предиктор (автоматически загружает модель)
predictor = create_predictor()

# Данные вибрации
vibration_x = [0.1, 0.12, 0.11, 0.13, 0.09] * 10
vibration_y = [0.08, 0.10, 0.09, 0.11, 0.07] * 10
vibration_z = [0.05, 0.06, 0.05, 0.07, 0.04] * 10
sampling_rate = 1000.0
temperature = 45.5

# Предсказываем состояние
result = predictor.predict(
    vibration_x,
    vibration_y,
    vibration_z,
    sampling_rate,
    temperature
)

print(f"Состояние: {result['status']}")
print(f"Уверенность: {result['confidence']:.2f}%")
print(f"Рекомендации: {result['recommendations']}")
```

### Пример 2: С вероятностями всех классов

```python
result = predictor.predict(
    vibration_x,
    vibration_y,
    vibration_z,
    sampling_rate,
    temperature,
    return_probabilities=True
)

# Вероятности всех классов
for class_name, prob in result['probabilities'].items():
    print(f"{class_name}: {prob:.2f}%")
```

## Формат результата

Модель возвращает словарь со следующими ключами:

```python
{
    "status": "норма",  # Название состояния на русском
    "status_code": 0,   # Код состояния (0-3)
    "confidence": 95.5, # Уверенность в процентах
    "probabilities": {   # Вероятности всех классов (если запрошено)
        "норма": 95.5,
        "износ внутреннего кольца": 2.1,
        "износ внешнего кольца": 1.8,
        "неисправность шарика": 0.6
    },
    "recommendations": [  # Список рекомендаций на русском
        "Продолжить мониторинг",
        "Проводить плановые проверки согласно графику"
    ]
}
```

## Извлечение признаков

Модель извлекает следующие типы признаков из вибрационных данных:

1. **Статистические признаки** (для каждой оси X, Y, Z):
   - Среднее значение
   - Стандартное отклонение
   - Дисперсия
   - Максимум и минимум
   - Размах (peak-to-peak)
   - RMS (Root Mean Square)
   - Асимметрия (skewness)
   - Эксцесс (kurtosis)
   - Медиана

2. **Частотные признаки** (FFT анализ):
   - Доминирующая частота
   - Амплитуда доминирующей частоты
   - Средняя и максимальная амплитуда
   - Энергия в частотной области
   - Количество пиков

3. **Признаки взаимодействия**:
   - Корреляции между осями X-Y, X-Z, Y-Z

4. **Температурные признаки**:
   - Температура
   - Нормализованная температура

## Интеграция с Backend

Модель может быть интегрирована в FastAPI backend через эндпоинт:

```python
from ml_model.predictor import create_predictor

predictor = create_predictor()

@app.post("/api/v1/predict")
async def predict_bearing_status(data: VibrationDataRequest):
    result = predictor.predict(
        data.vibration_x,
        data.vibration_y,
        data.vibration_z,
        data.sampling_rate,
        data.temperature
    )
    return result
```

## Технические детали

- **Алгоритм**: Random Forest Classifier
- **Количество деревьев**: 150 (настраивается)
- **Максимальная глубина**: 25 (настраивается)
- **Нормализация**: StandardScaler
- **Балансировка классов**: включена

## Примечания

- Модель обучена на синтетических данных. Для продакшена рекомендуется обучить на реальных данных.
- Минимальное количество точек вибрации: рекомендуется не менее 50 точек на ось.
- Частота дискретизации должна соответствовать реальной частоте измерений.

